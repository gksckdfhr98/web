<h1>백엔드 관련 기초 지식을 정리한 페이지 입니다.</h1>


※참고 : **[백엔드로드맵](https://github.com/devJang/developer-roadmap)**

# 목차

* [인터넷](#1-인터넷)
* [기본적인 프론트엔드 지식](#2-기본적인-프론트엔드-지식)
* [OS 및 일반적인 지식](#3-OS-및-일반적인-지식)
* [데이터베이스 상세 정보](#4-데이터베이스-상세-정보)
* [API에 대해서 배우기](#5-API에-대해서-배우기)


## 1. 인터넷

### 1-1. 인터넷은 어떻게 작동할까?
```

1) 인터넷은 모든 컴퓨터를 연결하고 어떤 일이 있어도 연결 상태를 유지할 수 있는 방법을 찾는 방법.
2) 두 개의 컴퓨터가 통신을 하면서 네트워크를 구성, 컴퓨터가 늘어날수록 케이블을 연결하면 복잡해진다.
3) 컴퓨터를 라우터에 연결하고 라우터끼리 연결하면서 확장한다.
4) 먼 곳에 통신을 하기 위해 모뎀을 이용해 네트워크를 전화 시설에 연결한다.(ISP 네트워크를 통해 연결)
5) 모든 컴퓨터에는 고유 IP주소가 있고 우리는 이를 통해 컴퓨터를 찾는다.

```

### 1-2. HTTP는 무엇인가?
```

1) hyertext transfer protocol로 html문서를 주고 받는데 쓰인다.(클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜)
2) 주로 TCP를 사용하고, HTTP/3부터는 UDP를 사용하며 port 80번을 쓴다.

```

### 1-3. 브라우저와 동작 원리
```

1) 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시
2) 자원은 html문서 또는 pdf,이미지 나 다른 형태, 자원의 주소는 uri에 의해 정해진다.
3) 렌데링 엔진으로 요청한 내용을 서버로부터 받아 브라우저 화면에 표시
4) html,xml,이미지를 표시할 수 있으며 플러그인이나 확장 기능을 이용해 pdf와 같은 유형도 표시 가능
5) 동작 원리는 다음과 같다.
html 문서를 파싱 > 브라우저 화면에 렌더링하기 위해 다루기 쉬운 구조로 바꿈 > css파일 파싱 > 렌더트리 구축 > 렌더트리 배치
> 렌더트리 그리기
5-1) 좀 더 나은 사용자 경험을 위해 모든 html을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작.

```

### 1-4. DNS와 작동 원리
```

1) dns랑 사람이 읽을 수 있는 이름을 ip주소로 변환하여 컴퓨터가 서로 통신할 수 있도록 한다.
2) 인터넷의 dns 시스템은 이름과 숫자 간의 매핑을 관리.
3) dns 서버는 이름에 대한 요청을 ip주소로 변환하여 사용자가 도메인 이름을 웹 브라우저에 입력할 때 해당 사용자를 어떤 서버에 연결할
것인지 제어, 이를 쿼리라고 함.

4) 작동 원리는 다음과 같다.
4-1) 웹 브라우저에 A를 입력하면 local dns에게 A라는 hostname에 대한 ip주소를 질의하여 local dns에 없으면 1차적으로 Root dns에 질의.
4-2) root dns로부터 com 도메인을 관리하는 tld(top-level domain) 서버 정보를 전달 받음.
4-3) tld에 A를 질의하면 tld에서 name.com 도메인을 관리하는 dns 서버 정보를 전달.
4-4) name.com 도메인을 관리하는 dns에 ip 주소를 질의하여 local dns가 ip주소를 응답받음.
4-5) local dns는 ip주소를 캐싱하고 ip주소를 사용자에게 전달.

```

### 1-5. 도메인 네임은 무엇인가? & 호스팅은 무엇인가?
```

1) 도메인네임 : 네트워크 상에서 원하는 호스트를 가리키는 이름
2) 호스팅 : 서버의 전체 혹은 일부를 이용할 수 있도록 임대해주는 서비스(즉, 개인이 서버를 관리하기보다는 전문 업체의 호스팅 서비스를 사용)
2-1) 웹 호스팅 : 여러 고객이 하나의 서버를 함께 사ㅇ용.
2-2) 서버 호스팅 : 고객이 단독 서버를 사용하는 형태.
2-3) 클라우드 서버 : 서버 호스팅을 가상화 한 것, 가상 서버를 단독으로 사용할 수 있는 형태. 고객이 필요할 때마다 서버 자원을 늘리거나 축소하여
유연하게 서버를 이용 가능.

```
[목차](#목차)


## 2. 기본적인 프론트엔드 지식
```

* html,css,javascript는 실습을 통해 기초 지식 습득. javascript만 일부 내용을 정리 하고자 한다.

1) JavaScript Event Loop
1-1) Javascript Engine : Javascript로 작성한 코드를 해석하고 실행하는 인터프리터다. Call stack, Task Queue, Heap 3영역으로 나뉜다.

* Call stack
* Javascript는 단 하나의 call stack을 사용한다. 즉, 하나의 함수가 실행되면 이 함수의 실행이 끝날 때까지 다른 어떤 task도 수행될 수 없다.

* Heap
* 동적으로 생성된 객체는 힙에 할당된다.

* Task Queue(Event Queue)
* 처리해야 하는 Task들을 임시 저장하는 대기 큐. Call stack이 비어졌을 때, 먼저 대기열에 들어온 순서대로 실행된다.
* Javascript에서 비동기로 호출되는 함수들은 Call stack에 쌓이지 않고 Task Queue에 enqueue된다. 이벤트에 의해 실행되는 함수들이 비동기로 실행.
* Javascript Engine이 아닌 Web API 영역에 따로 정의되어 있는 함수들은 비동기로 실행.
* Event loop는 현재 실행중인 task가 없는지 task queue에 task가 있는지를 반복적으로 확인

1-2) Javascript 비동기 처리 과정
* 비동기 작업으로 등록되는 작업은 task와 microtask, animationFrame 작업으로 구분된다.
* 처리 순서는 micro > animationFrame > task 순이다.
* microtask가 처리된 이후 animationFrame이 호출되고 이후 브라우저 렌더링이 발생한다.
* microtask에는 MutationObserver와 Promise가 해당된다.

2) Hoisting(끌어올리는 것)
* 변수의 정의가 그 범위에 따라 선언과 할당으로 분리되는 것.
* 선언문은 Javascript Engine 구동시 가장 최우선으로 해석하므로 hoisting되고, 할당 구문은 런타임 과정에서 이루어지기 떄문에 hoisting되지 않음.
ex) 함수 선언이 함수 실행 부분보다 뒤에 있더라도 Javascript Engine이 함수 선언을 끌어올리는 것.

3) Closure
* 두 개의 함수로 만들어진 환경으로 이루어진 특별한 객체의 한 종류, 환경은 클로저가 생성될 때 그 범위에 있던 여러 지역 변수들이 포함된 context
* 클로저를 통해서 Javascript에 private,public 속성/메소드를 구현할 수 있다.
* 외부 함수 호출이 종료되더라도 외부 함수의 지역 변수 및 변수 스코프 객체의 체인 관계를 유지할 수 있는 구조.
* 외부 함수에 의해 반환되는 내부 함수.

4) this
* arguments라는 유사 배열 객체와 함께 함수 내부로 암묵적으로 전달되는 것.
* 객체의 메서드를 호출할 때, A.B일 때 B 함수 내부의 this는 A를 가리킨다.
* 함수를 호출할 때, A.B일 때 A가 전역 객체가 되므로 this는 전역 객체에 바인딩 된다.
* 생성자 함수를 통해 객체를 생성할 때, new 키워드를 통해서 호출된 함수 내부에서의 this는 객체 자신이 된다.
* apply,call,bind를 통한 호출
* bind는 함수를 선언할 때, this와 파라미터를 지정.
* call과 apply는 함수를 호출할 때, this와 파라미터를 지정.
* apply는 첫번째 인자로 this를 넘겨주고 두번째 인자로 넘겨줘야 하는 파라미터를 배열의 형태로 전달.
* bind와 call은 각각의 파라미터를 하나씩 넘겨준다.

5) Promise
* 대부분의 작업들은 비동기로 이루어지는데 프론트엔드의 규모가 커지면서 코드의 복잡도가 높아지는 상황 발생.
* Promise 패턴을 사용하여 비동기 작업을 순차적으로 진행하거나, 병렬로 진행하여 컨트롤이 수월해짐.
* 또한, 예외처리에 대한 구조가 존재하기 때문에 오류 처리 등에 대해 보다 가시적으로 관리 가능.

* Promise를 사용하면 비동기 메서드에서 동기 메서드처럼 값을 반환할 수 있다.
* 최종 결과를 반환하는 것이 아닌, Promise를 반환해서 미래의 어떤 시점에 결과를 제공.
* 대기,이행,거부 중 하나의 상태를 가짐.
* new Promise(function(resolve,reject) ~~~ , 성공시 resolve 수행, 실패시 reject 수행.
* .then(fn) 메서드를 통해 비동기처리가 완료된 시점에서 fn 함수를 실행.
* catch()를 이용해 에러 처리, then()의 두 번째 인자로 에러 처리.

6) Async/Await
* 비동기 코드를 작성하는 새로운 방법, Promise에 만족하지 않고 더 훌륭한 방법을 고안해냄.
* function 앞에 async를 붙여주고, function 내부의 promise를 반환하는 비동기 처리 함수 앞에 await를 붙여준다.
* Promise보다 비동기 코드의 겉모습이 더 깔끔하다는 장점.

7) Arrow function
* 기존의 function 표현방식보다 간결하게 함수를 표현할 수 있다. 항상 익명이며 자신의 this,arguments,super,new.target을 바인딩하지 않음.
* 그래서 생성자로 사용할 수 없다.

```
※참고: [JavaScript](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/JavaScript)
[목차](#목차)


## 3. OS 및 일반적인 지식
```

1) os의 일반적인 작동방식
* 운영체제는 컴퓨터의 각종 자원을 효율적으로 관리하고 컴퓨터 HW와 User간의 인터페이스를 담당하는 시스템 프로그램.
* 사람이 HW와 SW를 편리하게 사용하며 컴퓨터의 성능을 높여주는 것이 1차 목표.
* 처리능력의 향상, 반환시간의 최소화, 사용 가능도의 향상, 신뢰도의 향상

* 멀티프로그래밍 : CPU에는 단 하나의 프로그램 밖에 올라가지 않기 때문에 메모리에 여러 프로세스들을 올려두고 I/O대기 상태가 되면
다음 job으로 넘어가 최대한 cpu가 놀지 않게 한다.
* 사용자가 현재 진행중인 작업에 대해 관여할 수 없다는 단점.

* 타임 셰어링 : 멀티태스킹, cpu가 스케쥴링을 통해 작업들을 빠르게 스위칭 하면서 동시에 프로그램이 작동하는 것처럼 느껴지게 한다.
멀티 태스킹을 위해 메모리에 여러 job을 올려 놓으면 부족 현상이 생길 수 있는데 스와핑을 통해 프로세스를 가상 메모리에 저장.
* 즉, 모든 job은 타임 슬라이스동안 cpu를 점유하고 그 시간이 끝나면 cpu를 양보.

* 인터럽트 : cpu가 job을 처리할 때, I/O 디바이스 등의 장치나 예외상황이 발생하여 처리가 필요한 경우 신호를 주어 처리할 수 있도록 하는 것.
* HW 인터럽트, SW 인터럽트로 나뉜다.

2) 프로세스 관리
* 프로세스 : 메인 메모리에 할당되어 실행중인 상태인 프로그램.

* PCB : 프로세스에 대한 모든 정보가 모여있는 곳
* 프로세스 상태, 번호(PID), program counter, register값, MMU정보, CPU점유 시간 등이 포함.
* 타임 셰어링에 의해서 프로세스를 수행하기 때문에 CPU에서 수행중인 프로세스가 나갈 때, 프로세스의 정보를 PCB에 저장한다.

* 프로세스 큐 : 프로세스는 여러 개가 한 번에 수행되므로 그에 따른 순서가 필요. 순서를 대기하는 곳이 큐이다.
* job queue : 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다림.
* ready queue : cpu 점유 순서를 기다림.
* device queue : I/O를 하기 위한 장치를 기다리는 큐.
* 순서를 정해주는 알고리즘이 스케줄링이다.

* scheduler
* medium-term scheduler는 주기적으로 메인 메모리에 있는 프로세스를 검사하여 보조기억장치로 옮길 프로세스를 찾는다.
* 장기간 사용하지 않는 프로세스를 하드디스크로 옮김(swap out), 나중에 이 프로세스가 다시 사용되려고 하면 메인 메모리에 할당(swap in)

* context switching
* cpu가 한 프로세스에서 다른 프로세스로 옮겨가는 것.
* dispatcher : 현재 cpu 데이터는 이전 프로세스의 pcb에 갱신, 새로 시작되는 프로세스의 pcb 데이터를 cpu로 복원.

3) 스레드와 동시성
* 스레드 : 프로세스 내에서 실행되는 흐름의 단위
* 멀티 스레드 : 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행, 프로세스의 메모리를 공유함.
* 동시성 : 멀티 코어에서 멀티 스레드를 동작시키는 방식, 한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질.

4) 기본적인 터미널 명령어

* grep : 파일에서 특정한 패턴을 찾는 명령어, 해당 문자열이 들어있는 파일을 찾아 그 문자열이 들어가 있는 라인을 화면에 출력
$ grep [option][문자열][파일명]
$ grep 패턴 *
$ grep 패턴 a* : a로 시작하는 모든 파일에서 해당 문자열이 들어있는 라인을 출력한다.

* awk : 파일에서 패턴이 일치하는 행을 찾아서 지정한 조치를 수행.
$ awk 'pattern' filename 조건
$ awk '{action}' filename 몇 번째 필드
$ awk 'pattern {action}' filename 무슨 조건에 몇 번째 필드

* sed : 필터링과 텍스트를 변환하는 스트림 편집기. 원본 변화없이, 출력 결과를 반환.
$ sed 's/찾을텍스트/바꿀텍스트/' 파일명

* lsof : 파일지시자가 제공해주는 키값(pid)를 사용하고 있는 목록을 보여줌
$ lsof

* curl : http 메시지를 쉘상에서 요청하여 결과를 확인하는 명령어
$ curl [옵션][URL]

* wget : 웹 상의 파일을 다운로드 받을 때 사용하는 명령어
$ wget [DOWNLOAD-URL]

* tail : 입력받은 파일의 마지막 부분을 출력하는 명령어
$ tail [OPTION]... [FILE]...

* head : 파일의 앞부분을 보여주는 명령어, 행 수나 용량을 지정할 수 있어 보고 싶은 분량을 지정할 수 있다.
$ head [옵션]... 파일명

* less : 텍스트 파일을 한 번에 한 화면씩 보여주는 터미널 페이저.
$ less [파일명]

* find : 파일 및 디렉토리를 검색할 때 사용하는 명령
$ find [OPTION...][PATH] [EXPRESSION...]

* ssh : 컴퓨터와 컴퓨터가 public network를 통해 서로 통신할 때 보안적으로 안전하게 통신을 하기 위해 사용하는 프로토콜
$ ssh username@hostname
$ ssh user@192.168.x.x

* kill : 프로세스에 특정한 signal을 보내는 명령어, 일반적으로 종료되지 않는 프로세스를 종료시킬 때 많이 사용.
$ kill -1
-n: (siganl의 종류 64까지 있음)

5) 메모리 관리
* 프로세스들을 위해 메모리를 할당하고 제거하며 보호하는 활동.

* 메모리 정책
* 적재 정책 : 디스크에서 언제 메모리로 프로세스를 가져와야 할지 정하는 것.
* 배치 정책 : 디스크에서 메모리로 가져온 프로세스를 어느 위치에 저장 할 것인지 정하는 것.
* 대치 정책 : 메모리가 충분하지 않을 때, 현재 메모리에 적재된 프로세스 중 제거할 프로세스를 결정하는 법.

6) 프로세스간 통신(IPC)
* 프로세스들 사이에 서로 데이터를 주고받는 행위, 프로세스들이 공유하는 메모리가 필요.
* 프로세스간 통신에 대한 3가지 방법

* 1.파이프
* 한 프로세스가 쓰고 다른 프로세스가 읽는 선입선출 형태의 큐, 통신을 위한 메모리공간(버퍼)을 생성.
* 파이프는 단방향의 통신, 따라서 양방향 통신을 위해서는 파이프를 2개 쓴다.
* 프로세스가 많아지면 메모리 공간의 낭비가 심해진다는 단점.

* 2.Unix Domain Socket
* 동일한 호스트 운영 체제에서 실행되는 프로세스 간에 데이터를 교환하기 위한 데이터 통신 엔드 포인트.

* 3.공유 메모리
* 여러 프로그램이 동시에 접근할 수 있는 메모리
* 프로세스 A가 메시지를 공유 메모리에 전송하면 프로세스 B가 공유 메모리의 메시지를 읽는 방식으로 동작.
* 대량의 정보를 다수의 프로세스에게 배포가능, 빠르고 효율적, 공유 메모리 공간에 대한 접근 제어가 필요.

7) 입출력(I/O) 관리
* 표준 입력(stdin) : 컴퓨터의 지시를 받거나 입력 데이터를 추가하기 위한 입력 장치.
* 표준 출력(stdout) : 컴퓨터 디스플레이에 문자열로 출력. 컴퓨터 실행 상태를 보고하거나 실행 결과가 표시되는 출력 장치.
* 표준 오류 출력(stderr) : 컴퓨터 실행 상태의 경과 보고 등이 표시되는 2번째의 표시 출력 장치.
* 표준 보조 입출력(stdaux) : 컴퓨터가 통신회선을 경유하여 접속되고 있는 단말기 등과 데이터를 주고 받기 위한 입출력 장치
* 표준 프린터 출력(stdprn) : 일반적으로 프린터에 문자열을 출력.

8) POSIX 기초(stdin,stdout,stderr,pipes)
* 이식 가능 운영 체제 인터페이스의 약자, 서로 다른 UNIX OS의 공통 API를 정리하여 이식성이 높은 유닉스 응용 프로그램을 개발하기 위한 목적.
* 한 운영체제에서 개발한 프로그램을 다른 운영체제에서도 쉽게 돌아가도록 하는 표준.

*표준 스트림 : 유닉스 계열 운영체제에서 컴퓨터 프로그램과 그 환경 사이에 미리 연결된 입출력 통로.
* stdin, stdout, stderr이 있다.
* echo foo 명령이 주어진다면 stdin으로 입력을 받아 echo에게 넘겨주고 stderr에 데이터를 저장하고 stdout에 데이터를 출력.

* 파이프 : 어떤 프로그램의 출력 결과를 다른 프로그램의 입력 값으로 쓰는 것.

9) 기본적인 네트워크 개념
* 네트워크 : 분산되어 있는 컴퓨터를 통신망으로 연결한 것.

* OSI 7 계층(물리,데이터링크,네트워크,트랜스포트,세션,프리젠테이션,애플리케이션)
* 물리 : 데이터 패킷을 전기나 광신호로 바꾸어 송수신
* 데이터 링크 : 네트워크 계층으로 부터 메시지를 비트로 변환(mac)
* 네트워크 : 두 원격 시스템간 연결성과 경로 선택 제공(라우터)
* 트랜스포트 : 데이터 전송 서비스 제공(신뢰적 전송)
* 세션 : 애플리케이션간 세션 구축,관리,종료시키는 역할(TCP/IP 세션)
* 프리젠테이션 : 한 시스템의 애플리케이션에서 보낸 정보를 다른 시스템의 애플리케이션 계층에서 읽을 수 있게 함(MIME,암호화)
* 애플리케이션 : 엔드유저와 컴퓨터가 통신(일반 응용 서비스)

```
[목차](#목차)

## 4. 데이터베이스 상세 정보
```

1) ORM(Object Relational Mapping)
* 객체와 관계형 데이터베이스의 데이터를 자동으로 연결해주는 것.
  * 객체 지향 프로그래밍은 클래스를 사용, 관계형 데이터베이스는 테이블을 사용.
  * 객체 모델과 관계형 모델 간에 불일치가 존재한다.
  * ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결.
  * 데이터베이스 데이터 <-매핑-> Object 필드

* 장점
* 객체 지향적인 코드로 인해 비즈니스 로직에 더 집중할 수 있게 도와줌.
  * SQL Query가 아닌 직관적인 코드(메서드)로 데이터를 조작할 수 있어 개발자가 객체 모델로 프로그래밍하는데 집중할 수 있도록 도와줌.
* 재사용 및 유지보수의 편리성 증가
* DBMS에 대한 종속성이 줄어든다.

* 단점
* 완벽한 ORM으로만 서비스를 구현하기가 어렵다.
* 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.

2) ACID
* 데이터의 유효성을 보장하기 위한, 트랜잭션의 특징들의 앞글자를 딴 단어

* Atomicity(원자성)
* 모든 작업이 반영되거나 모두 롤백되는 특성.

* Consistency(일관성)
* 데이터는 미리 정의된 규칙에서만 수정이 가능한 특성.

* Isolation(고립성)
* A와 B 두개의 트랜젝션이 실행되고 있을 때, A의 작업들이 B에게 보여지는 정도.

* Durability(영구성)
* 한번 커밋된 트랜젝션의 내용은 영원히 적용되는 특성

3) 트랜잭션
* 여러 작업들을 하나로 묶은 단위, 한 덩어리의 작업들은 모두 실행되거나 실행되지 않는다.

4) N+1 문제
* Car-> Wheel인 일대 다 관계가 있다고 가정 했을 때, 각 자동차에 대해 바퀴 목록을 인쇄해야 한다고 가정.
* select * from car; (1) > 각 car에 대해 select * from wheel where carid = ? (n) --> 총 n+1 번 데이터베이스를 왕복한다.
* 하지만, select * from wheel을 하면 왕복횟수는 n+1에서 2로 줄어든다. 대부분의 ORM 도구는 n+1 선택을 방지하는 방법을 제공.

5) 데이터베이스 정규화
* 데이터베이스의 설계를 재구성한느 테크닉이다. 정규화를 통해 불필요한 데이터를 없앨 수 있고 삽입/갱신/삭제 시 발생할 수 있는 각종 이상현상들을 방지할 수 있다.

* 정규화 법칙
  * 1차 정규화 : 각 row마다 column 값이 1개씩만 있는 것.
  * 2차 정규화 : 기본키 중에 특정 칼럼에만 종속된 컬럼이 없어야 한다는 것.
    * 테이블을 분리함으로써 해결.
  * 3차 정규화 : 기본키 이외의 다른 칼럼이 그외 다른 칼럼을 결정할 수 없는 것.
    * 2차 정규화와 마찬가지로 테이블을 분리함으로써 해결 가능.
  * BCNF : 3차 정규형을 만족하면서 모든 결정자가 후보키 집합에 속한 정규형.
    * 일반 칼럼이 후보키를 결정하는 경우가 3차 정규화는 만족하면서 BCNF는 만족하지 않는 경우이다.

6) 인덱스와 작동 방식
* 대용량의 데이터에서 특정 데이터를 검색하기 위해 테이블을 full scan하는 것이 아닌 인덱스가 적용된 컬럼의 테이블을 따로 파일로 저장해놓고, 그것을 검색해서 찾음.
* 인덱스는 key, column 순으로 정렬되어 있기 떄문에 특정값을 찾다가 해당 범위를 넘어서는 값을 만나면 멈춘다.(범위 스캔)

* B-tree
* root block, branch block, leaf block이 있고 leaf block의 깊이가 모두 동일하게 균형이 잡혀 있다.
* 각 노드에 값이 있다.
* 탐색 과정
  * 찾고자 하는 값이 branch block에서 가장 왼쪽 값보다 작거나 같을 때는 왼쪽 포인터
  * branch block 사이에 있으면 사이 포인터
  * branch block에서 가장 큰 값보다 크면 오른쪽 포인터로 찾아간다.
  * 이 과정을 통해 leaf block을 찾고 그 안에 찾고자 하는 값이 있으면 성공이고 없으면 실패.

* 인덱스를 적용해야 하는 시점
  * select문의 where, join에서 좋은 성능을 발휘, insert,update,delete문에서 성능이 떨어짐.
  * insert문
  * 새로운 데이터를 삽입하면서 테이블, 인덱스 테이블에도 생성을 해줘야 하며 만약 인덱스의 leaf block이 꽉 찬 상태라면 다른 block으로 밀려나    야할 데이터가 생기고 이 모든 과정을 redo에 기록되는 수고가 생김.
  * delete문
  * 기존 테이블은 레코드를 삭제하고 그 공간을 다른 레코드가 사용할 수 있지만 인덱스 테이블은 사용 안함 표시만 하고 자리를 그대로 차지.
  * update문
  * delete 후 insert 하는 식으로 처리하기 때문에 부하가 많아짐.
  
  * 즉, 검색은 많고 insert,delete,update가 적게 일어나는 테이블에서 인덱스를 사용하면 좋음.
  
```
[목차](#목차)

## 5. API에 대해서 배우기
```

1) REST(Roy fielding의 paper 읽기)
* API
* 소비자가 필요한 콘텐츠(호출)와 생산자에게 필요한 콘첸츠(응답)를 구성.
* 컴퓨터나 시스템과 상호 작용하여 정보를 검색하거나 기능을 수행하고자 할 때 사용자가 원하는 것을 시스템에 전달할 수 있게 지원하여 시스템이 요청을 이해하고 이행하도록 함.

* REST A
* 자원을 이름으로 구분하여PI 해당 자원의 정보를 주고 받는 모든 것을 의미.
* 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍쳐의 한 형식.
* HTTP URI를 통해 자원을 명시하고, HTTP Method(POST,GET,PUT,DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것.
* 모든 자원에 고유 ID인 HTTP URI를 부여.
* 최근의 서버 프로그램은 다양한 브라우저와 모바일 디바이스에서도 통신할 수 있어야하기 때문에 REST가 필요.
* 하나의 자원은 JSON,XML,TEXT,RSS 등 여러 형태의 Representation으로 나타내어 질 수 있다.(JSON이나 XML이 일반적)

2) JSON
* 데이터를 저장하거나 전송할 떄 많이 사용되는 경량의 데이터 교환 형식
* Javascript에서 객체를 만들 때 사용하는 표현식
* 서버-클라이언트 간의 교류에서 일반적으로 많이 사용된다.
* javascript를 이용하여 JSON 형식의 문서를 쉽게 javascript 객체로 변환할 수 있는 이점이 있다.
* 다른 프로그래밍 언어를 이용해서도 쉽게 만들 수 있다. 

* XML vs JSON
* XML : 데이터 값 양쪽으로 태그가 있다.
* JSON : 중괄호 형식, 값을 ','로 나열하기에 그 표현이 간단.

* JSON 형식
* name-value 형식의 쌍
* 값들의 순서화된 리스트 형식

* JSON의 문제점
* AJAX는 단순히 데이터만이 아니라 Javascript 자체도 전달할 수 있다. 받은 데이터가 Javascript가 될 수도 있고 악성 스크립트가 될 수 있다.
* 위와 같은 이유로 받은 내용에서 순수하게 데이터만 추출하기 위한 JSON 관련 라이브러리를 따로 사용.

* JSON.parse() : JSON 형식의 텍스트를 자바스크립트 객체로 변환.
* JSON.stringify() : 자바스크립트 객체를 JSON 텍스트로 변환.
```

### 5-1. 인증
```

1) Oauth
* 인증을 위한 오픈 스탠다드 프로토콜, 사용자가 A의 인터넷 서비스 기능을 다른 애플리케이션에서도 사용할 수 있게 한 것.
* 로그인과 Oauth는 그 차이가 있다. 로그인이 사원증이라면, Oauth는 방문증으로 볼 수 있다.
* 둘은 각각 인증 받은 권한이 다르다.

* OpenID vs Oauth
* OpenID의 주요 목적은 인증, Oauth의 주요 목적은 허가.
* OpenID는 OpenID Provider에서 사용자의 인증 과정을 처리.
* Oauth를 사용자 인증을 위한 방법으로 쓸 수 있지만 근본 목적이 중요.

* 용어
* user : service provider에 계정을 가지고 있으면서 consumer를 이용하려는 사용자
* service provider : Oauth를 사용하는 open api를 제공하는 서비스
* consumer : Oauth 인증을 사용해 service provider의 기능을 사용하려난 애플리케이션이나 웹 서비스
* request token : consumer가 service provider에게 접근 권한을 인증받기 위해 사용하는 값, 인증이 완료된 후에는 access token으로 교환.
* access token : 인증 후 consumer가 service provider의 자원에 접근하기 위한 키.

2) 기본적인 인증

3) 토큰 인증

4) JWT

```
[목차](#목차)
