## OOP란?

* 현실 세계를 프로그래밍으로 옮겨와 사물을 객체로 보고 그 객체의 특징과 기능을 뽑아 프로그래밍하는 기법.
* 객체를 연결시켜 프로그래밍하면 상속, 캡슐화, 다형성을 이용해 코드 재사용성을 증가시키고 유지보수를 감소시켜주는 장점.

* 클래스 : 객체를 만들어 내기 위한 설계도
* 객체 : 클래스를 기반으로 선언된 대상
* 인스턴스 : 객체에 메모리가 할당되어 실제로 활용되는 객체

## 상속

* 자식 클래스가 부모 클래스의 필드와 메소드를 물려받는 것.
* private 필드와 메소드는 상속 불가.
* 중복된 코드 줄일 수 있고, 유지보수가 편리

## 다형성

* 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것.(오버로딩, 오버라이딩)
* 하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것.

## 캡슐화

* 객체접근에 있어서 정보를 숨기고 객체의 연산을 통해서만 접근이 가능하게 하는 것.
* 유지보수나 확장시 캡슐화를 통해 오류의 범위를 최소화 할 수 있다.

## 자바의 메모리 영역

* static 영역
* static 변수, 전역 변수, 코드에서 사용되는 클래스 정보들이 올라감.
* 프로그램 종료시 까지 메모리에 남아있게 된다.

* 스택
* 지역 변수, 메소드 등이 할당되는 영역

* 힙
* new 연산자를 통해 동적할당된 객체들이 저장되고, 메모리는 가비지 컬렉션에 의해 관리.

## static

* static 영역에 변수가 올라가 프로그램 종료시까지 메모리에 남아있게 됨.
* 객체의 생성 없이 바로 접근 가능.

## JVM

* 자바와 운영체제 사이의 중계자 역할을 함, 자바가 운영체제 종류에 상관없이 돌아갈 수 있도록 함.
* 메모리를 자동으로 관리(GC)

* 자바 실행 과정
* Java Compiler에 의해 Java Source(.java) 파일은 Byte Code(.class)로 변환.
* Class Loader는 변환된 Byte Code 파일을 JVM 내로 class를 로드.
* Excution Engine은 JVM 메모리에 배치된 Byte Code들을 명령어 단위로 실행.
* GC는 더 이상 참조되지 않거나 null인 객체의 메모리를 해제시켜 공간 확보.
* Runtime Data Area는 JVM 메모리로 Java Application이 실행하면서 할당받은 메모리영역이다.

## 가비지 컬렉터

* Java Application은 JVM 위에서 구동, JVM에서는 Java Application이 사용하는 메모리를 관리하는데 JVM의 기능 중
더 이상 사용하지 않는 객체를 청소하여 공간을 확보하는 가비지 컬렉터가 있다.

* GC 과정
* 객체가 생성되어 Eden 영역에 올라감.
* Eden 영역이 꽉 차면 Servior 영역으로 넘어감, 객체의 크기가 Servior 영역보다 크다면 Old 영역으로 이동
* Old 영역에 들어간 객체는 풀 GC, 메이저 GC가 발생하지 않는한 GC되지 않음.

* 풀 GC : 메모리 전체를 대상으로 하는 GC
* 메이저 GC : Old, Perm 영역에서 발생하는 GC
* 마이너 GC : Young 영역에서 발생하는 GC

* GC 방식
* Serial Collector
* 하나의 CPU로 Young 영역과 Old 영역을 연속적으로 처리, 컬렉션이 수행될 때 애플리케이션이 정지.
* Old 영역에서 쓰레기 객체를 한 곳으로 모아 삭제.

* Parallel Collector
* 다른 CPU가 GC의 진행시간 동안 대기 상태로 남아 있는 것을 최소화
* Serial Collector의 Young 영역에서 진행하는 컬렉션을 병렬 방식으로 처리해 GC의 부하를 줄이고 성능을 향상.

## 인터페이스

* 모든 메소드가 추상 메소드로 이루어진 클래스.
* 공동 작업시 충동을 방지하기 위해 사용한다.
* A,B가 각각 a번역, b번역 메소드 코드를 작성할 때 인터페이스를 상속받아 사용하게 된다면 클래스의 이름만 알고 있다면
번역 메소드를 호출했을 때 어떤 번역 기능을 하는지 기대할 수 있다는 것.

* 교체 용이
* 다른 방식으로 바꾸고 싶을 때, 클래스를 개발해서 이름만 교체하면 되므로 간편하다.

* 다중 상속
* 필요한 인터페이스를 상속 받아서 구현하면 여러 기능들을 구조적으로 포함.

## 메모리 상수풀 영역

* 힙 영역의 고정 영역에 생성되어 프로그램 종료시까지 계속 유지되는 메모리 영역.
* JVM에서 관리하며 프로그래머가 작성한 상수에 대해서 최우선적으로 찾아보고 없으면 상수풀에 추가한 이후 그 주소값을 리턴.

## jdbc

* 자바에서 데이터베이스를 접속할 수 있도록 해주는 자바 API.
* JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트 하는 방법들을 제공.

## 직렬화

* 자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동.
* 객체를 바이트 배열로 변환하는 것을 직렬화라고 함.
* 반대 과정을 역직렬화라고 함.

## serialVersionUID를 선언하는 이유?

* JVM은 직렬화나 역직렬화를 하는 시점에 클래스에 대해 version 번호를 부여.
* 클래스의 정의가 바뀌면 version 번호도 새로 할당.
* 직렬화, 역직렬화 과정에서 클래스 버전을 확인하기 위한 용도.

## 리플렉션

* 컴파일 시간이 아닌 실행 시간에 동적으로 특정 클래스의 정보를 객체화를 통해 추출해 해는 프로그래밍 기법.

## 클래스 멤버 변수의 초기화 순서

* static 변수 선언부는 클래스가 로드 될 때 제일 먼저 초기화
* 필드 선언부는 객체가 생성될 때, heap 메모리에 올라가고 그 다음 생성자 block이 초기화.

## Servlet과 JSP

* Servlet은 서버에서 웹페이지 등을 동적으로 생성하거나 데이터 처리를 수행하기 위해 자바로 작성된 프로그램.
* JSP는 html 내부에 자바 코드를 삽입하는 형식 ( 서블릿의 단점을 보완하기 위해 만든 서블릿 기반의 스크립트 기술)
* 서블릿을 작성하지 않고 간편하게 웹 프로그래밍을 구현.
* 서블릿을 이용하면 화면 인터페이스 구현에 너무 많은 코드를 필요로 하는 비효율적인 측면이 있다.

## 제너릭

* 클래스 내부에서 사용하는 데이터의 타입을 클래스의 인스턴스를 생성할 때 결정하는 것.
* 객체의 타입을 컴파일 시점에 체크하기 떄문에 타입 안정성을 높이고 형 변환의 번거로움을 줄임.

## 컬렉션 클래스에서 제너릭을 사용하는 이유

* 컴파일러는 특정한 타입만 포함될 수 있도록 컬렉션을 제한.
* 컬렉션 클래스에 저장되는 인스턴스 타입을 제한하여 런타임에 발생할 수 있는 모든 예외를 컴파일 타임에 잡아낼 수 있음.

* 컬렉션 : 데이터의 집합, 그룹

## pojo

* 특정 기술에 종속되어 있지 않은 순수한 자바 객체.
* 특정 기술에 종속하게 된다면 확장성이 떨어지는 단점이 있기 때문에 pojo 개념이 등장함.

## 박싱과 언박싱

* 박싱 : 프리미티브 타입을 Wrapper 클래스로 변환
* 언박싱 : Wrapper 클래스를 프리미티브 타입으로 변환
* 제네릭은 primitive type을 받지 않기 때문에 wrapper 클래스를 이용해야함.

* primitive type 쓰는 이유?
* 자바는 모든 객체를 힙에 저장하는데 힙은 스택보다 상대적으로 속도가 느림.

## 상속과 컴포지션의 차이

* 상속 : 자식 클래스가 부모 클래스의 메소드와 필드를 물려받는 것.

* 컴포지션 : 기존 클래스를 확장하는 대신 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조.
* 새로운 클래스는 기존 클래스의 영향이 적어지고 새로운 메소드를 추가해도 안전.

* 언제 상속을 사용하는가?
* is-a 관계인지 확인, A가 와인이고 B가 레드 와인이라면 "B가 A인가?" 확인.

## JVM의 역할

* 자바를 실행하기 위한 가상 기계, 자바와 운영체제 사이의 중계자 역할.
* 자바 컴파일러가 자바 소스 파일을 컴파일하면 .class라는 byte code로 변환. 이 byte code는 기계어가 아니므로 운영체제에서 실행되지 않음.
* 운영체제가 이해할 수 있도록 해석해주는 것이 JVM

## interface와 abstarct 비교

* interface : 추상 클래스이며 추상 메소드와 상수만 변수로 갖는다. 상속 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있음.
* abstarct : 추상 메소드를 하나 이상 가진 클래스이며 자신의 생성자로 객체 생성이 불가능.
* 하위 클래스를 참조하여 상위 클래스의 객체를 생성해 하위 클래스를 제어하기 위해 사용.

## 다형성

* 하나의 메소드나 클래스가 다양한 방법으로 동작하는 것을 의미.(오버로딩, 오버라이딩)
* 하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것.

## map과 hashmap의 시간복잡도

* map : 특정 키에 대한 값을 찾는 과정에서 binary tree 알고리즘을 이용.
* 최상 O(logn), 최악O(n), 

* hashmap : 특정 키에 대한 값을 찾는 과정에서 hash table을 이용.
* 이상적으로 O(1)의 시간을 소요하지만, 실제로는 hash table의 크기에 반비례하는 O(n)의 시간을 소요.

## 동적할당

* 실행 시간(runtime)동안 사용할 메모리 공간을 할당하는 것.

## 스프링과 mvc 패턴

* Spring : 자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크. java se로 된 자바 객체 pojo를 java ee에 의존적이지 않게 연결해주는 역할
* 크기와 부하 측면에서 경량화, IOC 기술로 애플리케이션의 느슨한 결합을 도모

* mvc : 개발을 할 때, model,view,controller 3가지 형태로 나우어 비즈니스 처리 로직과 ui를 분리시켜 서로 영향없이 개발 하기 수월함.
* model : 비즈니스 로직을 담당하여 데이터베이스를 관리하는 부분
* view : 사용자에게 화면에 무엇인가를 보여주기 위한 역할
* controller : 모델과 뷰 사이에서 정보 교환을 할 수 있도록 연결시켜주는 역할.

## AOP

* 관점 지향 프로그래밍. 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하는 것.
* 핵심 비즈니스 로직 앞과 뒤에서 공통 관심사를 수행할 수 있게 하면서 중복 코드를 줄일 수 있는 방식.

## DI

* IOC : 객체가 내부적으로 조작할 객체를 직접 생성하지 않고 외부로부터 주입 받는 기법.
* 객체를 외부로부터 주입해주는 작업을 DI(의존성 주입)이라고 함.

* IOC 컨테이너 : 객체의 생성과 관계설정, 사용, 제거 등의 작업을 대신 해줌. (이런 객체들을 Bean이라고 함.)

## mvc1 , mvc2 패턴 차이

* mvc1
* JSP 안에서 로직 처리를 위해 자바 코드가 함께 사용. 요청이 오면, 직접 자바빈이나 클래스를 이용해 작업을 처리하고 이를 클라이언트에게 출력.
* 구조가 단순하지만 JSP 내에서 html코드와 자바 코드가 같이 사용되면서 유지보수가 어려움.

* mvc2
* 모든 처리를 JSP에서만 담당하는 것이 아닌 서블릿을 만들어 역할 분담을 하는 패턴.
* 요청 결과를 출력해주는 뷰만 JSP가 담당, 비즈니스 로직에 해당하는 컨트롤러의 역할은 서블릿이 담당.
* 유지보수가 용이해지는 장점, 습득하기 힘들고 구조가 복잡.

## spring filter와 interceptor

* 실행되는 시점에 차이가 있음.
* filter는 웹 애플리케이션에 등록, interceptor는 spring의 context에 등록.
* 컨트롤러에 들어가기 전 작업을 처리하기 위해 사용하는 공통점이 있지만 호출되는 시점이 다름.

* spring filter
* 요청과 응답을 거른 뒤 정제하는 역할

* Interceptot
* dispatcher servlet이 컨트롤러를 호출하기 전,후로 처리.

## spring과 spring boot

* 스프링 부트 : 스프링에서 사용하는 프로젝트를 간편하게 셋업할 수 있는 서브 프로젝트.
* 독립 컨테이너에서 동작할 수 있기 때문에 임베디드 톰캣이 자동으로 실행됨.

## spring mvc구조 흐름.

* dispatcher servlet이 클라이언트로부터 요청을 받으면 이를 요청할 핸들러의 이름을 알기위해 핸들러 매핑에게 물어본다.
* 핸들러 매핑은 요청 url을 보고 핸들러 이름을 dispatcher servlet에게 알려준다.
* 이때 핸들러를 실행하기 전/후에 처리할 것들을 인터셉터로 만들어 준다.
* dispatcher servlet은 해당 핸들러에게 제어권을 넘겨주고, 이 핸들러는 응답에 필요한 서비스를 호출하고 렌더링해야하는 뷰 이름을 판단하여
dispatcher servlet에게 전송
* 받은 뷰 이름을 뷰 리졸버에게 전달해 응답에 필요한 뷰를 생성.
* 뷰는 dispatcher servlet에게서 받은 model과 controller를 활용해 원하는 응답을 생성해서 다시 보내줌.
* dispatcher servlet은 뷰로부터 받은 것을 클라이언트에게 응답.

## 30. dao, dto

* dao : 데이터베이스의 데이터에 접근하기 위한 객체. 데이터베이스를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 객체.
* dto : 계층간 데이터 교환을 위한 자바 bean. vo도 같은 기능을 하지만 read only 속성을 가진 차이가 있다.

## 쿠키와 세션

* http의 비연결성, 비상태성이라는 특징을 보완하기 위해 사용.

* 쿠키
* 서버가 사용자의 웹 브라우저에 저장하는 데이터, 쿠키가 다르면 서버에서는 다른 브라우저로 인식.
* 사용자에게 저장되기 때문에 임의로 고치거나 지울 수 있고 가로채기 쉬어 보안에 취약

* 세션 
* 일정 시간동안 같은 브라우저로부터 들어오는 일련의 요구사항을 하나의 상태로 보고 그 상태를 유지시키는 기술.
* 웹 브라우저 당 1개씩 생성되어 웹 컨테이너에 저장되며 브라우저 종료시 소멸됨.

## mybatis

* 기존은 자바 소스 안에 sql문을 작성, mybatis는 xml에 sql문을 작성하여 유지보수 및 가독성이 좋음.

## tdd

* 테스트 주도 개발. 작은 단위의 테스트 케이스를 작성하고 이를 통과하는 코드를 추가하는 단계를 반복하여 구현.

## array vs List

* array : 다수의 데이터를 묶어 효율적인 관리가 가능한 자료형. 정의와 동시에 길이가 지정되며 바꿀 수 없는 정적 자료형
* 데이터에 접근하기 위한 인덱스가 존재하고 이를 통해 데이터를 가져오기 때문에 조회 속도가 빠름.

* List : 자동으로 데이터를 수용할 수 있는 크기가 조정되고 순서가 있는 자료형.
* 추가, 삭제가 빠름.

