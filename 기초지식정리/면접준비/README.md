# 목차

* [프로그래밍 공통](#1-프로그래밍-공통)
* [자료구조](#2-자료구조)
* [알고리즘](#3-알고리즘)
* [네트워크](#4-네트워크)
* [운영체제](#5-운영체제)
* [데이터베이스](#6-데이터베이스)
* [백엔드](#7-백엔드)

## 1. 프로그래밍 공통

### OOP란

* 현실 세계를 프로그래밍으로 옮겨와 사물들을 객체로 보고, 그 객체로부터 특징과 기능을 뽑아 프로그래밍하는 기법.
* 재사용성과 변형가능성을 높일 수 있다.

### OOP의 5가지 설계 원칙

* SRP(Single Responsibility Principle, 단일 책임 원칙) : 클래스는 단 1개의 목적을 가져야하며, 클래스를 변경하는 이유는 단 하나의 이유여야함.
* OCP(Open-Closed Principle, 개방 폐쇄 법칙) : 클래스는 확장에는 열려 있고, 변경에는 닫혀 있어야 함.
* LSP(Liskov Substitution Principle, 리스코프 치환 법칙) : 상위 타입의 객체를 하위 타입으로 바꾸어도 프로그램은 일관되게 동작해야 함.
* ISP(Interface Segregation Principle, 인터페이스 분리 원칙) : 클라이언트는 이용하지 않는 메소드에 의존하지 않도록 인터페이스를 분리
* DIP(Dependency Inversion Principle, 의존 역전 법칙) : 클라이언트는 추상화(인터페이스)에 의존해야 하며, 구체화(구현된 클래스)에 의존해서는 안됨.

### 절차 지향 vs 객체 지향

* 절차지향 프로그래밍
  - 순차적인 처리를 중요시
  - 대표적인 언어로 C언어
  - 컴퓨터의 처리구조와 유사해 실행속도가 빠르다.
  - 코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다.

* 객체지향 프로그래밍
  - 실제 세계의 사물들을 객체로 모델링하여 개발을 진행하는 프로그래밍 기법
  - 대표적인 언어로 Java
  - 캡슐화, 상속, 다형성 등과 같은 기법 이용 가능. 다형성은 동일한 키보드의 키가 다른 역할을 하는 것처럼 하나의 메소드나 클래스가 다양한 방법으로
    동작하는 것을 의미.
  - 절차지향 언어보다 실행속도가 느리다.

### RESTful API

* HTTP 통신에서 어떤 자원에 대한 CRUD 요청을 resource와 method로 표현하여 특정한 형태로 전달하는 방식. 아래와 같은 것들로 구성
* Resource(자원,uri)
* Method(요청 방식, GET, POST, PUT, DELETE)
* Representation of Resource(자원의 형태, JSON or XML 등)

### TDD(Test-Driven Development)

* 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스로, 개발자는 우선 요구되는 기능에 대한 테스트케이스와 코드를 작성하고 상황에 맞게
  리팩토링하는 테스트 주도 개발 방식을 의미.
* 개발자는 테스트를 작성하기 위해 해당 기능의 요구사항을 확실히 이해해야 하기 때문에 개발 전에 요구사항에 집중할 수 있도록 도와주지만
  테스트를 위한 진입 장벽과 작성해야 하는 코드의 증가는 단점으로 뽑힘.
  
### DDD(Domain-Driven Design)

* 실세계에서 사건이 발생하는 집합인 Domain을 중심으로 설계하는 방법.
* 도메인들이 서로 상호 작용하며 설계하는 것이 도메인 주도 설계. 도메인을 각각 분리되어 있는데, 이러한 관점에서 MSA를 적용하면 용이한 설계 가능.
* 문맥에 따라 객체의 역할이 바뀔 수 있는 것.

### MSA(MicroService Architecture)

* 모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 모놀리식 아키텍쳐의 한계점을 극복하고자 등장.
* 1개의 시스템을 독립적으로 배포가능한 각각의 서비스로 분할.
* 각각의 서비스는 RESTful API를 통해 데이터를 주고받으며 1개의 큰 서비스를 구성.

* 장점
  - 일부 서비스에 장애가 발생하여도 전체 서비스에 장애가 발생하지 않음.
  - 각각의 서비스들은 서로 다른 언어와 프레임워크로 구성될 수 있다.
  - 서비스의 확장이 용이하다.
  
* 단점
  - 서비스가 분리되어 있어, 테스팅이나 트랜잭션 처리 등이 어렵다.
  - 서비스 간에 RESTful API로 통신하기 때문에 그에 대한 비용이 발생.
  - 서비스간의 호출이 연속적이기 때문에 디버깅이 어렵다.
  
### 함수형 프로그래밍

* 부수효과가 없는 순수 함수(데이터의 값을 변경시키지 않으며 객체의 필드를 설정하는 등의 작업을 하지 않는 함수)를 이용하여 프로그램을 만드는 것.
* immutable data, first class citizen으로서의 함수가 특징.

* first class citizen(1급 객체)
  - 변수나 데이터에 할당 할 수 있어야 함.
  - 객체의 인자로 넘길 수 있어야 함.
  - 객체의 리턴값으로 리턴 할 수 있어야 함.

### 메모리 구조(코드 영역, 데이터 영역, 힙 영역, 스택 영역)

* 코드 영역
  - 실행할 프로그램의 코드가 저장되는 영역(텍스트 영역)
  - 사용자가 프로그램 실행 명령을 내리면 OS가 HDD에서 실행 코드를 메모리로 올림.
  - CPU는 코드 영역에 저장된 명령어를 하나씩 처리.
  
* 데이터 영역
  - 프로그램의 전역 변수와 정적 변수가 저장되는 영역. 프로그램의 시작과 함께 할당되며, 종료되면 소멸
  - 정적 변수 : 정적으로 할당되는 변수, 프로그램 실행 전반에 걸쳐 변수의 수명 유지.
  
* 힙 영역
  - 프로그래머가 직접 관리할 수 있는 메모리 영역으로 이 공간에 메모리를 할당하는 것을 동적 할당이라고 부름.
  - Java에서는 가비지 콜렉터가 자동으로 해제. 낮은 주소에서 높은 주소로 메모리가 할당.
  
* 스택 영역
  - 함수의 호출과 함께 할당되며 지역 변수와 매개 변수가 저장되는 영역. 스택 영역에 저장되는 함수의 호출 정보를 스택프레임이라고 함.
  - 함수의 호출이 완료되면 소멸. 높은 주소에서 낮은 주소로 메모리가 할당.
  
### Parameter와 Argument의 차이

* Parameter : 함수를 선언할 때 사용된 변수
* Argument : 함수가 호출되었을 때 함수의 파라미터로 전달된 실제 값

### Call by Value , Call by Reference

* Call by Value
  - 인자로 받은 값을 복사하여 처리하는 방식
  - Call by Value에 의해 넘어온 값을 변경해서 원래의 값이 보존된다.
  - 값을 복사하여 넘기기 때문에 메모리 사용량이 증가한다.

* Call by Reference
  - 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 주는 방식
  - 값을 복사하지 않고 직접 참조하기 때문에 속도가 빠르다.
  - 원래의 값에 영향을 주는 리스크가 존재.
  
  
### 프레임워크와 라이브러리 차이

* 라이브러리 : 사용자가 흐름에 대한 제어를 하며 필요한 상황에 가져다가 쓸 수 있다.
* 프레임워크 : 전체적인 흐름을 자체적으로 제어.

* 실행 흐름에 대한 제어 권한이 어디 있는지에 따라 달라짐. 프레임워크를 사용하면 사용자가 관리해야 하는 부분을 프레임워크에 넘김으로써
  신경써야 할 것을 줄이는 제어의 역전이 적용.
    
### 병렬 처리 프레임워크의 종류와 특징

* Hadoop
  - HDFS를 활용해 데이터를 주고 받음.
  - 데이터가 여러 노드에 분산되어 저장되기 때문에 손실의 우려가 없다는 장점.
  - File I/O를 기반으로 작동하기 때문에 처리 속도가 느림.

* Spark
  - In-Memory 상에서 데이터를 주고받고 연산을 수행.
  - 메모리를 사용해 데이터를 처리하기 때문에 Hadoop보다 속도가 100배 정도 빠름.
  - 장애가 발생한 경우 응용 프로그램을 처음부터 다시 시작.

### 동기와 비동기의 차이

* 동기방식
  - 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식
  - 순서에 맞추어 진행되기 때문에 제어하기 쉬움.
  - 여러가지 요청을 동시에 할 수 없어 효율이 떨어짐.

* 비동기방식
  - 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식
  - 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용 가능.
  - 작업이 완료된 결과를 제어하기 어렵다.

### SQL Injection

* 공격자가 악의적인 의도를 갖는 구문을 삽입하여 공격자가 원하는 SQL을 실행하도록 하는 웹해킹기법.
* 공격을 방지하기 위해 특수문자 및 SQL 예약어들을 필터링하거나 SQL 오류 메세지를 노출하지 않는 등의 방법을 취해야함.

## 2. 자료구조

### 자료구조와 알고리즘

* 자료구조는 데이터를 원하는 목적에 맞게 저장하기 위한 규칙.
* 알고리즘은 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임.

### 스택,큐,트리,힙

* 스택
  - 먼저 넣게 되는 자료가 나중에 나오게 되는 FILO 구조.
* 큐
  - 먼저 넣게 되는 자료가 먼저 나오게 되는 FIFO 구조
* 트리
  - 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 Graph의 특수한 형태로, 계층이 있는 데이터를 표현하기에 적합.
* 힙
  - 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조, 완전이진트리

### 우선순위 큐

* 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조
* 힙을 사용하여 구현
* 복잡도는 O(logn)

### 해시 테이블

* (key,value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용.
* key값에 해시함수를 적용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조.
* 평균적으로 O(1)의 시간복잡도를 갖지만 해시의 index값이 충돌이 발생한 경우 충돌된 index값에 대해 연결된 데이터들을 조회하여 원하는 값을
  조회하기 때문에 O(N)까지 증가할 수 있다.
  
### LinkedList, ArrayList

* ArrayList
  - 데이터들이 순서대로 늘어선 배열의 형식을 취함.
  - 원하는 데이터에 무작위 접근 가능
  - 리스트의 크기에 제한, 크기를 조정하는 것은 많은 연산이 필요
  - 추가/삭제를 위해서는 임시 배열을 생성하여 복제해 시간이 오래 걸림.
* LinkedList
  - 자료의 주소값으로 서로 연결된 형식
  - 리스트의 크기에 영향 없이 데이터 추가 가능
  - 데이터를 추가하기 위해 새로운 노드를 생성하여 연결하므로 추가/삭제 연산이 빠름.
  - 무작위 접근이 불가능, 순차 접근만 가능.

### 큐, 스택의 구현

* 큐
  - Array로 구현시 poll 이후 객체를 앞당기는 작업 필요
  - List로 구현시 객체 1개만 제거하면 되므로 삽입 및 삭제가 용이 (LinkedList 이용)
* 스택
  - List로 구현시 객체를 제거하는 작업 필요
  - Array로 구현시 삭제할 필요 없이 index를 줄이고 초기화 하면 됨. (Array 이용)

## 3. 알고리즘

### insertion sort

* 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열과 비교하여 자신의 위치를 찾아 삽입하는 알고리즘.
* best - O(n), avg - O(n^2), worst - O(n^2)

### selection sort

* 해당 순서에 원소를 넣을 위치는 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘.
* best,avg,worst - O(n^2)

### bubble sort

* 인접한 두 원소를 비교하여 정렬하는 알고리즘. O(n^2)

### quick sort

* 매우 빠른 정렬 속도를 가진 분할 정복 알고리즘. 리스트를 비균등하게 분할
* pivot을 설정하고 pivot보다 큰 값과 작은 값으로 분할하여 정렬
* O(nlogn) , 리스트가 불균등하게 나눠지는 경우 시간복잡도가 O(n^2)까지 나빠질 수 있음.

### Heap sort

* 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최소값부터 하나씩 꺼내서 정렬하는 자료구조
* 힙소트가 유용한 경우는 전체 값을 정렬하는 것이 아닌 가장 큰 값 또는 작은 값 몇개만을 필요로 하는 경우
* O(nlogn)

### merge sort

* 주어진 배열을 크키가 1인 배열이 될 때까지 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘.
* O(nlogn) ( 각각의 단계에서 n번 비교, 깊이가 logn) - 비교
* O(2nlogn) (이동연산 2n, 깊이 logn) - 이동

## 4. 네트워크

### 웹 동작 방식

* 사용자가 브라우저에 url 입력
* 브라우저는 dns를 통해 서버의 ip주소를 받음.
* http 프로토콜을 사용하여 http 요청 메시지 생성
* tcp/ip 연결을 통해 http 요청이 서버로 전송.
* 서버는 http 프로토콜을 활용해 http 응답 메세지를 생성
* tcp/ip 연결을 통해 컴퓨터로 전송
* 도착한 http 응답 메시지는 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있음.

### TCP와 UDP 차이

* TCP는 3-way handshaking 과정을 통해 연결을 설정. 높은 신뢰성 보장, 속도가 느림.
* 신뢰성이 중요한 파일 교환에 쓰임.
* UDP는 비연결형 서비스로 신뢰성이 떨어짐. 수신 여부를 확인하지 않기 때문에 속도가 빠름.
* 실시간성이 중요한 스트리밍에 자주 사용.

### GET, POST

* GET : 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식.
* url에 데이터가 노출되기 때문에 보안적으로 중요한 데이터를 포함하면 안됨.
* POST : 데이터를 추가 또는 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식.
* 완전히 안전한 것은 아니지만 url에 데이터가 노출되지 않아 GET보다는 안전.

### 공인ip, 사설ip

* 공인 ip
* 전 세계에서 유일한 ip로 ISP(인터넷 서비스 공급자)가 제공하는 ip주소
* 외부에 공개되어 있기 때문에 인터넷에 연결된 다른 장비로부터 접근이 가능.

* 사설 ip
* 어떤 네트워크 안에서 사용되는 ip주소
* ipv4의 부족으로 인해 모든 네트워크가 공인ip주소를 사용하는 것이 불가능하기 때문에 네트워크 안에서 라우터를 통해 할당받는 가상 주소.
* 별도의 설정 없이 외부에서 접근 불가능.

### OSI 7계층

* 1계층(물리계층) : 데이터를 전기 신호로 바꾸어주는 계층
* 2계층(데이터링크 계층) : 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층
* 3계층(네트워크 계층) : 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층
* 4계층(전송 계층) : 최종 수신 프로세스로 데이터의 전송을 담당하는 계층
* 5계층(세션 계층) : 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
* 6계층(표현 계층) : 데이터의 형식을 정의하는 계층
* 7계층(응용 계층) : 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층

### HTTP 프로토콜

* 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜. TCP/IP 위에서 작동.
* 상태를 가지고 있지 않은 stateless 프로토콜이며 method, path, version, headers, body로 구성.

### HTTP vs HTTPS

* http는 평문 데이터를 전송하는 프로토콜이기 때문에 제 3자에 의해 조회될 수 있음.
* http에 암호화가 추가된 프로토콜이 https. https는 자신의 공개키를 갖는 인증서를 발급하여 보내는 메세지를 수신자의 공개키로 암호화.
* 수신자는 자신의 비밀키로 복호화.

### 웹

* 웹 통신
* 브라우저에 도메인 입력 -> dns 서버에 ip주소를 요청 -> 수신한 ip주소에 해당한느 웹 서버에 접속

* 크로스 브라우징
* 각기 다른 브라우저에서 동일한 정보 제공을 위한 기능.

* url vs uri : 모든 url은 uri다.
* url : 서버 상의 파일들의 위치
* uri : 인터넷 상의 자원을 식별하기 위한 문자 구성

* get : 클라이언트에서 서버로 데이터를 보낼 때, 주소 뒤에 key와 value가 결합된 쿼리 스트링 형태로 전달하는 것.
* post : 주소가 아닌 body에 데이터를 넣어서 전송.

## 5. 운영체제

### Byte Ordering

* 데이터가 저장되는 순서.

* Big Endian
* MSB가 가장 낮은 주소에 위치하는 저장 방식
* 네트워크에서 데이터를 전송할 때 주로 사용됨.
* offset=0인 Byte를 보면 양수/음수를 바로 파악 가능.

* Little Endian
* MSB가 가장 높은 주소에 위치하는 저장 방식
* 마이크로프로세서에서 주로 사용
* 가장 낮은 주소에 부호값이 아닌 데이터가 오기 때문에 바로 연산 가능.

* MSB : 최상위 비트, 최고값을 갖는 비트 위치

### 메모리

* 컴퓨터에서 작업을 수행하기 위해 처리 대상이나 결과 등을 저장하기 위한 공간.
* 프로그램을 실행하기 위한 정보들은 메모리에 저장되어 처리.

### 프로세스, 쓰레드

* 프로세스
* 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
* 운영체제로부터 독립된 메모리 영역을 할당받음.
* 프로세스들은 독립적이기 때문에 통신하기 위해 IPC를 사용.
* 프로세스는 최소 1개의 쓰레드를 갖고 있다.

* IPC
* 프로세스들 사이에 서로 데이터를 주고받는 행위

* 쓰레드
* 프로세스 내에서 할당받은 자원을 이용해 동작하는 실행 단위
* 쓰레드는 프로세스 내에서 stack만 따로 할당 받고, heap,code,data 영역은 공유.
* 쓰레드는 프로세스의 자원을 공유하기 때문에 다른 쓰레드에 의한 결과를 즉시 확인 가능.

### Context Switching

* 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정.
* 현재 실행중인 프로세스의 상태(context)를 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 복구

* 인터럽트
* CPU가 프로세스를 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요함을 CPU에게 알리는 것.

### 멀티 프로세스 vs 멀티 쓰레드

* 멀티 프로세스
* 하나의 프로그램을 여러 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리
* 1개의 프로세스가 죽어도 자식 프로세스 이외의 다른 프로세스들은 계속 실행.
* Context Switching을 위한 오버헤드가 발생.
* 프로세스는 각각 독립적인 메모리를 할당받았기 때문에 통신하는 것이 어렵다.

* 멀티 쓰레드
* 하나의 프로그램을 여러 쓰레드로 구성하여 각 쓰레드가 1개의 작업을 처리
* 쓰레드는 메모리를 공유하기 때문에 통신이 쉽고 자원을 효율적으로 사용 가능.
* 여러 쓰레드가 하나의 공유 자원에 동시에 접근하는 경우 문제가 발생할 수 있음.

### 뮤텍스 vs 세마포어

* 뮤텍스
* 여러 쓰레드가 공유 자원에 동시에 접근할 때 베타적 제어를 위한 구조.
* 어떤 쓰레드에게 소유된다면 뮤텍스는 비신호 상태.

* 세마포어
* 여러 프로세스와 쓰레드가 동시에 특정 리소스에 접근할 수 있도록 임의로 허용치를 정하는 것.

### 가상메모리, 페이지폴트

* 가상메모리
* RAM의 부족한 용량을 보완하기 위해, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식.
* OS는 프로세스들의 내용(페이지) 중에서 덜 중요한 것들을 하드디스크에 옮겨 놓고, 관련 정보를 테이블에 기록.

* 페이지 폴트
* CPU가 프로세스를 실행할 때 페이지 테이블을 통해서 페이지를 조회하는데 실제 메모리 주소에 원하는 페이지가 없는 상황.
* 가상 메모리를 통해서 해당 데이터를 가져옴. 페이지폴트가 발생하면 I/O에 의한 속도의 저하 발생.

### 페이지 교체 알고리즘, LRU

* LRU
* 페이지를 교체하기 위한 알고리즘. 가장 오랫동안 사용하지 않은 페이지를 선택.
* 페이지를 교체하는 이유는 가상 메모리를 통해 조회한 페이지는 다시 사용될 가능성이 높기 때문.
* 페이지 교체를 위해서는 실제 메모리에 존재하는 페이지를 가상 메모리로 옮기고, 가상 메모리에서 조회한 페이지를 실제메모리로 로드.
* 어떤 페이지를 가상메모리로 옮길 것이냐는 문제 발생 -> LRU 알고리즘 이용.

### CPU의 메모리 I/O 도중 생기는 병목 현상 해결 방법

* 메모리를 계층화하여 병목현상을 해결. 자주 접근하는 데이터의 경우에는 캐시에 저장하여 접근 속도를 향상시킴으로서 부하를 줄임.

### 데드락

* 둘 이상의 쓰레드가 lock을 획득하기 위해 기다리는데 이 lock을 잡고 있는 쓰레드도 똑같이 다른 lock을 기다리며 서로 블록 상태에 놓이는 것.
* 다수의 쓰레드가 같은 lock을 동시에 다른 명령에 의해 획득하려 할 때 발생.

* 해결 방법
* 우선 순위를 선정해 자원을 선점하도록 함, 공유 불가능한 상호 배제 조건을 제거

* 프로그램 : 특정 작업을 수행하는 소프트웨어
* 프로세스 : 프로그램이 실행되어 메모리나 cpu와 같은 자원을 할당 받음.
* 스레드 : 프로세스를 구성하는 하나의 단위.

* lock : 쓰레드 동기화 메커니즘, 모든 객체가 갖고 있음

### 동기화 객체

* 사용자 모드 동기화용 객체

* 크리티컬 섹션
* 내부 구조가 단순해 동기화 처리에 있어 속도가 빠름. 동일한 프로세스 내에서만 사용 가능.
* 프로세스 하나에 여러 개의 스레드가 공유 리소스에 접근할 때 베타적 제어를 하기 위한 구조.

* 운영체제가 제공하는 동기화용 커널 객체 ( 크리티컬 섹션보다 느림, 훨씬 더 복잡한 동기화에 사용됨)
* 일정 시점에 2가지 상태 중 1가지를 가짐.
* 신호 상태 : 스레드의 실행을 허가한 상태
* 비신호 상태 : 스레드의 실행을 허가하지 않은 상태, 신호상태가 될 때까지 스레드는 블록된다.

* 뮤텍스
* 크리티컬 세션이 쓰이는 곳에 대신 사용될 수 있음.
* 프로세스 간에도 사용할 수 있다는 장점, 그만큼 속도는 느림.(같은 프로세스 내에서는 크리티컬 세션과 차이 거의 없음)
* 어떤 스레드에게 소유가 된다면 뮤텍스는 비신호 상태.

* 세마포어
* 여러 스레드나 프로세스가 특정 리소스에 접근할 수 있도록 임의로 허용치를 정하는 것.

## 6. 데이터베이스

### 인덱스

* 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조.

* 인덱스의 자료구조
* 해시 테이블
* 컬럼 값으로 생성된 해시를 기반으로 인덱스를 생성.
* 시간 복잡도가 O(1), 연속적인 데이터를 위한 순차 검색이 불가능.

* B+ tree
* 자식 노드가 2개 이상인 B-tree를 개선시킨 자료구조.
* BTree의 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 하였다.
* O(logn)

### 클러스터링 vs 리플리케이션

* 클러스터링
* 여러 개의 db를 수평적인 구조로 구축하여 Fail Over한 시스템을 구축하는 방식
* 동기 방식으로 노드들 간의 데이터를 동기화
* 1개의 노드가 죽어도 다른 노드가 살아 있어 시스템을 장애없이 운영 가능
* 여러 노드들 간의 데이터를 동기화하는 시간이 필요.

* 리플리케이션
* 여러 개의 db를 권한에 따라 수직적인 구조로 구축하는 방식.
* 비동기 방식으로 노드들 간의 데이터를 동기화
* 비동기 방식으로 데이터가 동기화 되어 지연시간이 없다.
* 노드들 간의 데이터가 동기화되지 않아 일관성있는 데이터를 얻지 못할 수 있다.

## DB 정규화

* 제1정규형 : 모든 속성 값이 원자 값을 갖도록 분해
* 제2정규형 : 제1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이 되도록 분해.
(완전 함수 종속 : 기본키의 부분집합이 다른 값을 결정하지 않는 것.)
* 제3정규형 : 제2정규형을 만족하고, 기본키가 아닌 속성이 기본키에 직접 종속(비이행적 종속)하도록 분해
(이행적 종속 : A->B->C가 성립하는 것으로 이를 A,B 와 B,C로 분해하는 것.)
* BCNF 정규형 : 제3정규형을 만족하고, 함수 종속성 X->Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해.

## 트랜잭션

* 하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법.

## Hint

* SQL을 튜닝하기 위한 지시구문.
* 옵티마이저가 최적의 계획을 SQL문을 처리하지 못하는 경우에 개발자가 직접 최적의 실행 계획을 제공하는 것.

## 데이터베이스 튜닝

* DB튜닝은 데이터베이스의 구조나 운영체제 등을 조정하여 데이터베이스 시스템의 성능을 향상시키는 작업.
* DB 설계 튜닝 -> DBMS 튜닝 -> SQL 

## 프로시저

* 일련의 쿼리를 하나의 함수처럼 수행하기 위한 쿼리의 집합.
* 데이터베이스에 대한 일련의 작업을 정리한 절차를 관계형 데이터베이스 관리 시스템에 저장한 것.

### 7. 백엔드

## 많은 트래픽이 발생한 경우 대처

* scale up : 서버에 CPU나 RAM 등을 추가하여 서버의 하드웨어 스펙을 향상
* scale out : 서버를 여러 대 추가하여 시스템을 증가

## CDN

* 물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공하기 위한 기술.
* 서버를 분산시켜 캐싱해두고, 빠르게 다운 받을 수 있게 함.

## CORS

* 도메인이 다른 2개의 사이트가 데이터를 주고받을 때 발생하는 문제.
* 서버 내에서 요청이 허락된 도메인에만 데이터를 주기 위함.
* 요청을 허락하기 위해서는 Access-control-allow-origin: 도메인이나 \*와 같은 내용을 response 헤더에 추가해주어야함.

## was, ws

* ws : 정적인 파일을 제공하기 위한 서버 (아파치)

* was : 동적인 데이터를 제공하기 위한 서버, 동적인 정보를 처리하여 웹 서버에 정적인 정보를 제공 (톰캣)
* 일반적으로 웹서버의 기능을 내재하고 있어 웹 서버 없이도 서비스가 가능

## 디자인 패턴

* 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 문제들이 또 발생했을 때 재사용할 수 있는 해결책.

## di,dl,ioc,aop

* di : 의존성 주입. 각 클래스 간의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해 주는것.
* dl : 의존성 검색. 저장소에 저장되어 있는 빈에 접근하기 위해 특정 컨테이너가 제공하는 API를 이용하여 검색. 컨테이너 종속성이 증가함.
* ioc : 제어의 역전. 각 클래스 간의 의존관계 설정에 대한 권한을 프레임워크에 넘기는 것.
* aop : 관점 지향 프로그래밍. 어떤 로직을 기준으로 핵심적인 관점과 부가적인 관점으로 나누어 그 관점을 기준으로 각각 모듈화 하는것.

* java bean : 데이터를 표현하는 것을 목적으로 하는 자바 클래스

## spring security

* 사용자가 아이디와 비밀번호로 로그인을 요청
* AuthenticationFilter에서 UsernamePasswordAuthenticationToken을 생성하여 AuthenticationManager에게 전달
* Manager는 등록된 AuthenticationProvider를 조회하여 인증을 요구
* Provider는 UserDetailService를 통해 입력받은 아이디에 대한 사용자 정보를 DB에서 조회
* 입력받은 비밀번호를 암호화하여 DB의 비밀번호와 매칭되는 경우 인증이 성공된 UsernameAuthenticationToken을 생성하여
AuthenticationManager로 반환
* Manager는 Token을 Filter로 전달함.
* Filter는 전달받은 Token을 LoginSuccessHandler로 전송하고, 토큰을 response 헤더에 추가하여 반환함.
